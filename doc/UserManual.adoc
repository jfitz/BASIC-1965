BASIC-1965
==========

Overview
--------

BASIC-1965 is an implementation of an early variant of the BASIC language.

My references are Kemeny and Kurtz's "BASIC Programming" (John Wiley and Sons, 1967) and James S. Coan's "Basic BASIC" (Hayden, 1978).

I call this "K&K BASIC" (after "K&R C" for Kernighan and Ritchie's C book.).

Initial impressions
-------------------

BASIC-1965 is really primitive!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

BASIC-1965 is an interpreter.
BASIC-1965 caches the results of constant operations (such as 3 / 5).

The BASIC-1965 language has no exception handling.
Invalid input, dividing by zero, and numeric overflow or underflow will cause execution to stop.
There are no try/catch, no begin/rescue, no ON ERROR capabilities.

BASIC-1965 is designed for processing numeric data.
There are no capabilities for text variables ("string" variables), no MID$() function, no text input.
(The PRINT and WRITE statements handle text literals, and the INPUT statement allows for a text literal as a prompt.)

Space characters are insignificant in most places.
When loading a program (or accepting new statements from the user), BASIC-1965 removes all spaces and then parses the line.
When saving the program to a file and when listing the program for the user, BASIC-1965 inserts space characters to separate keywords and variable names.
The two places that BASIC-1965 preserves spaces from the original statement are text literals and REMARK statements.

BASIC-1965 is really fussy!
~~~~~~~~~~~~~~~~~~~~~~~~~~~
BASIC-1965 keeps the spirit of the original BASIC language, as much as possible.
Everything must be in upper case, except for text literals in PRINT, WRITE, and INPUT statements.
Commands ("RUN", "LIST"), statements ("PRINT", "LET"), function names, and variable names must be in upper case.
Lower case causes an error.

Keywords and tokens
-------------------
This implementation of BASIC tokenizes the program text and then parses the tokens.
When tokenizing, BASIC builds the longest legal token from available text.
This can lead to some problems, when legal constructs can be confused for keywords.

For example:

	10 LET S = 1
	20 LET P = 10
	30 FOR I = S TO P
	40 PRINT I
	50 NEXT I
	99 END

The above program is legal, but will be parsed incorrectly.
Line 30 contains the text "S TO P" which will be tokenized as "STOP" (remember that spaces are not significant) and not as the intended variable S, keyword 'TO', and variable P.

The solution is to use an underscore character, which is a break character for the tokenizer and a null token for the parser.

The corrected program is:

	10 LET S = 1
	20 LET P = 10
	30 FOR I = S _ TO P
	40 PRINT I
	50 NEXT I
	99 END

The underscore stops the tokenizer and forces it to accept S as a token and then procede with TOP which will be tokenized as 'TO' and P (as there is no 'TOP' keyword).

Differences from K&K BASIC
--------------------------

I have changed a few things:

- The single quote is used for a comment on a line
- The PRINT statement semicolon operator spaces text items together and numeric items apart
- The RND() function can have zero parameters
- The RND(X) function uses the passed value as an upper bound for the result. K&K BASIC ignores this parameter. Use the -–ignore-rnd-arg option to match K&K.
- The MAT assignment statement dimensions the target variable, so an earlier DIM is not needed
- User-defined functions may have multiple parameters
- You may have multiple user-defined functions with the same names and different signatures
- The ARR statements are not mentioned in Kemeny and Kurtz or in Coan

Running BASIC-1965
------------------

Interactive mode
~~~~~~~~~~~~~~~~

This is the classic mode, in which the user may edit programs and run them in the BASIC environment.
You may use any of the immediate commands (see below).

Interactive mode displays a prompt when it is ready for input.
The default prompt is 'READY'.
The prompt may be changed with the --prompt command-line option and the 'OPTION PROMPT' command.
Short prompts (length of one character) are displayed when BASIC is ready for input.
Long prompts (more than one character) are displayed when BASIC is ready for input but not after the entry of a program line.

Run mode
~~~~~~~~

This option runs BASIC-1965 and also loads a specified BASIC program and then either lists or runs it.
When the BASIC program ends, BASIC-1965 ends.

|==========
|Option |Effect
|--run filename |Specifies the file to load and run. May be abbreviated as -r
|--no-timing |Suppress the CPU time usage at the end of the output. Useful for comparing output when running tests.
|--profile |Display profile information after a program is run.
|--list filename |Specifies the file to load and list. May be abbreviated as -l
|--pretty filename |Specifies the file to load and pretty-print. May be abbreviated as -p
|--parse filename |Specifies the file to load and parse.
|--analyze filename |Specifies the file to load and analyze.
|--base 0/1 |Set the minimum for subscripts to either 0 or 1. Default is 0.
|--no-cache-const-expr |Disables caching of results of constant expressions.
|--no-detect-infinite-loop |Disables checks for infinite loops.
|--echo-input |Echoes console input to output. Useful in run mode when redirecting input from a text file.
|--field-sep-semi |Sets field separator for ARR PRINT and MAT PRINT statements to semicolon, which provides narrow spacing.
|--forget-fornext |Forgets the control value when a FOR/NEXT loop terminates, if it was undefined when the loop started.
|--no-heading |Supress the header and trailer messages.
|--ignore-rnd-arg |The RND function ignores its argument and provides a number between zero and one. This matches the behavior of certain BASICs, including K&K.
|--implied-semicolon |When printing items not delimited by a comma or semicolon, provide spacing as if a semicolon was provided. (Normally the items have no spaces between them.)
|--int-floor |The INT function truncates towards negative infinity. (Normally towards zero.)
|--lock-fornext |Lock control variables to FOR/NEXT loops. Variables can be read but not changed.
|--match-fornext |Require exact pairing of FOR/NEXT loops. The default allows programs to jump out of an inner loop and continue the outer loop.
|--precision |Sets the precision for numeric variables. Default is 6, maximum is 16. Set to "INFINITE" for maximum precision provided by Ruby.
|--print-width width |Specifies a print width. Lines will wrap at the specified column. Default value is 72.
|--prompt PROMPT |Specifies the command prompt. Single-character prompts have no linefeed and occur more often.
|--promptd PROMPT |Specifies the debugger prompt. Single-character prompts have no linefeed and occur more often.
|--prompt-count |INPUT statements prompt the user with the number of expected values.
|--provenance |When displaying a variable in a trace, also display the line number where it was set.
|--qmark-after-prompt |On an INPUT line, print the question mark after the prompt.
|--randomize |Forces new sequences of numbers from the RND() function on successive runs.
|--require-initialized |Require that variables are initialized before they are used.
|--semicolon-zone-width |Enables print zones for semicolon carriage control.
|--trace |Print each statement prior to executing it (useful for debugging). Does the same thing as the 'OPTION TRACE TRUE' command in interactive mode, but from the command line.
|--tty |Print output slowly, emulating the speed of an ASR-33 Teletype. Provides a better experience with some programs (often games) in which slow output lets your anticipation build. The fast output of modern computers displays information quickly, and TTY mode lets you read each line as it is "printed".
|--tty-lf |Similar to --tty but delays only the newline characters, not each individual character. Useful with --trace when debugging.
|--wrap |Wraps subscripts out of range back into range.
|--zone-width width |Specifies a zone width. PRINT statements will position output separated by commas in zones. Default is 16.
|==========

Immediate commands
------------------

Immediate commands are executed on the command line.
They are not stored as part of the program.
They have no line number.
They are available only in interactive mode.

LOAD
~~~~

Loads a stored program into memory.
Sorts statements by line number.
Clears the current program prior to loading the new one.

Syntax:	LOAD filename

The 'filename' argument must be enclosed in quotes.

Clears all breakpoints.

SAVE
~~~~

Saves the current program to disk.
Will overwrite an existing file without prompting.

Syntax:	SAVE filename [OPTION] [BREAK]

The 'filename' argument must be enclosed in quotes.
The OPTION option includes OPTION settings in the file.
The BREAK option includes breakpoints and conditions in the file.

NEW
~~~

Clears the current program.
Does not ask to save a loaded program.

Syntax:	NEW

Clears all breakpoints.

LIST
~~~~

Lists the current program on the screen.

Syntax:	LIST [line specification]

The line specification may be in the form of a single line number, a range (two numbers separated by a hyphen), or a starting line and a count separated by a plus sign.

Examples:
|==========
|Command |Result
|LIST |Lists the entire program.
|LIST 100 |Lists line 100, if it exists. If the line does not exist, nothing is printed.
|LIST 100-199 |Lists all lines from line 100 to (and including) line 199.
|LIST 100+10 |Lists line 100 and the next 10 lines, regardless of their line nunbers.
|LIST 100+ |Lists line 100 and the next 20 lines.
|==========

RUN
~~~

Runs the current program.

Syntax:	RUN

Program execution occurs in two phases.
The first phase checks each statement for errors and executes some statements.
Any error detected at this stage will halt execution.
An error may be a syntax error or another error.
GOTO and GOSUB statements with undefined targets are examples of errors.

Statements executed in this first phase are the DATA, FILES, and DEF statements.
They are executed only once in a program, even if the path of execution travels to them multiple times.

The second phase executes statements, starting with the lowest-numbered statement and following the path of execution.

BREAK
~~~~~

Sets or displays breakpoints.

Syntax: BREAK line-number [IF condition]
Syntax: BREAK

To set a breakpoint, type 'BREAK' followed by a line number.
To display breakpoints, type 'BREAK' with no arguments.

Examples:

	BREAK 100
	BREAK 220 IF A <> 0
	BREAK 302 IF LEN(A$) > 0 AND ABS(T) < 100
	BREAK

Multiple conditional breakpoints may be set for the same line.

Breakpoints may be set for lines that do not exist.
The RUN command checks for breakpoints set for lines that do not exist and reports an error.

NOBREAK
~~~~~~~

Clears or displays breakpoints.

Syntax: NOBREAK line-number [IF condition]
Syntax: NOBREAK

To clear a breakpoint, type 'NOBREAK' followed by a line number.
To display breakpoints, type 'NOBREAK' with no arguments.

Examples:

	NOBREAK 100
	NOBREAK 220
	NOBREAK

Clearing the breakpoints for a line clears all breakpoints, absolute and conditional, for that line.

CROSSREF
~~~~~~~~

Lists the numeric literals, text literals, functions, and variables used in the program, along with the line numbers on which they appear.
For variables, assignments are listed on one line and references are listed on a second line.
The line with assignments shows the variable and an equals sign.

DELETE
~~~~~~

Removes lines from the program.

My experience with other BASIC interpreters is that lines can be deleted by simply typing a line number and pressing RETURN.
(That is, entering an "empty" line with line number and nothing else.)
That technique does not work with BASIC-1965, as BASIC-1965 allows empty lines to be part of a program.

So how to remove a line from a program?
Replacing a line with an empty line is possible, and certainly makes the offending line "go away" from execution, but what if we want to really remove a line?

That's what the DELETE command does.

DELETE uses the same specification as the LIST command.

Syntax:	DELETE [line specification]

If the list specification is a single line, it is deleted immediately.
If the list specification is a range, the lines are displayed and the user must confirm the operation.

The DELETE command with no specification (implying the entire program) does not delete the program but does nothing.
(To delete the entire program, use the NEW command.)

PRETTY
~~~~~~

Lists the current program on the screen, adjusting the spacing between keywords, variable names, and literals.

Syntax:	PRETTY [line specification]

The line specification is the same as the line specification for the LIST command.

PROFILE
~~~~~~~

Lists the current program on the screen in "pretty" mode, with additional information about the most recent run.
The profile information is enclosed in parentheses immediately after line numbers.

The line

    10 LET A = 10

will appear in the profile as

    10 (0.0005/1) LET A = 10


Syntax:	PROFILE [line specification]

The line specification is the same as the line specification for the LIST and PRETTY commands.

If option TIMING is TRUE, the profile information lists the total execution time for the statement and the number of times the statement was executed.
If option TIMING is FALSE, the profile information lists only the number of times the statement was executed.
The latter configuration is useful for regression tests.

Counts are reset at the start of each execution.

Profiling excludes the first phase of processing of certain lines (DATA, FILES, and DEF FN).
These lines are processed before the program begins, and they do nothing when executed in the main execution.
For example, placing a DATA statement inside of a FOR/NEXT loop does not cause the lines data values to be stored multiple times.

RENUMBER
~~~~~~~~

Renumbers lines in the current program.

Syntax: RENUMBER
Syntax: RENUMBER step
Syntax: RENUMBER step,start

Modifies the current program, changing each line number.
The first line is assigned the starting line number.
Each successive line is assgned a number a step higher than the previous line.

When no values are specified, the renumbering starts at 10 with steps of 10.
When one value is specificed, the renumbering starts at that value and steps at that value.
When two values are specified, the renumberind starts at the second value and steps at the first value.
When more than two values are specified, only two are used and the rest are ignored.

Each statement which contains a line number (GOTO, GOSUB, IF) is modified to use the corresponding new line number.

RENUMBER also adjusts breakpoints, if any are set.

DIMS
~~~~

Displays the dimensioned variables that have been defined in DIM statements.

VARS
~~~~

Displays the variables that have been assigned values.

UDFS
~~~~

Displays the defined user-defined functions.


TOKENS
~~~~~~

Similar to LIST, the TOKENS command displays a line or group of lines, showing the tokens identified by the tokenizer.

Syntax:	TOKENS [line specification]

The line specification is the same as the line specification for the LIST command.

PARSE
~~~~~

Similar to LIST and TOKENS, the PARSE command displays a line or group of lines, showing the tokens identified by the parser. 

Syntax:	PARSE [line specification]

The line specification is the same as the line specification for the LIST command.

ANALYZE
~~~~~~~

Analyzes the code.
Compiles metrics for complexity and lists lines which are not reachable.
Complexity metrics include lines of code, comment density, comprehension effort, McCabe complexity, and Halstead complexity.
Comprehension effort is my own measure of complexity, counting the number of operations in each statement.

OPTION
~~~~~~

Display or set various options for the BASIC interpreter.

Syntax: OPTION
Syntax: OPTION option
Syntax: OPTION option value

The first form ('OPTION' by itself) lists the options and their current values.
The second form lists a specific option and its current value.
The final form sets the value for an option.

These options can be initialized on the command line.
The OPTION command overrides the command-line setting.

|==========
|Option |Settable |Data Type |Default |Effect
|BASE |NLP |numeric |0 |Sets the base for arrays and matrices to either 0 or 1
|CACHE_CONST_EXPR |NLP |TRUE or FALSE |TRUE |Cache result of operations on constant values and re-use instead of re-calculate
|DEFAULT_PROMPT |NLP |String |"? " |Changes the prompt for INPUT statements
|DETECT_INFINITE_LOOP |NLP |TRUE or FALSE |TRUE |Enables the detection of infinite loops
|ECHO |NLP |TRUE or FALSE |FALSE |Echoes input (useful for testing)
|FIELD_SEP |NLP |COMMA, SEMI, NL, or NONE |COMMA |Controls spacing of values in ARR PRINT and MAT PRINT statements
|FORGET_FORNEXT |NLP |TRUE or FALSE |FALSE |Forgets value of control value after final NEXT, if value was not defined at start
|HEADING |NLP |TRUE or FALSE |TRUE |Displays the opening and closing lines that identify BASIC
|IGNORE_RND_ARG |NLP |TRUE or FALSE |FALSE |Ignores the argument to RND(), needed for some old BASIC programs
|IMPLIED_SEMICOLON |NLP |TRUE or FALSE |FALSE |Assume that a semicolon is specified between arguments to PRINT without intervening carriage control specified
|INT_FLOOR |NLP |TRUE or FALSE |FALSE |Sets truncation towards negative infinity instead of towards zero
|LOCK_FORNEXT |NLP |TRUE or FALSE |FALSE |Do not allow changes to FOR/NEXT control variables within the loop
|MATCH_FORNEXT |NLP |TRUE or FALSE |FALSE |Requires execution of NEXT to match FOR
|MAX_LINE_NUM |N |numeric |9999 |Maximum line number allowed
|MIN_LINE_NUM |N |numeric |1 |Minimum line number allowed
|NEWLINE_SPEED |NLP |numeric |0 |Limit printing speed only for newlines
|PRECISION |NLP |numeric 1 to 16, or "INFINITE" |6 |Sets the precision for numeric values
|PRINT_SPEED |NLP |numeric |0 |Limit printing speed (a value of 10 emulates an old TeleType)
|PRINT_WIDTH |NLP |numeric |72 |Wrap output at the specified column; 0 disables wrapping
|PROMPT |NL |string |READY |Sets the text of the command prompt
|PROMPTD |NL |string |DEBUG |Sets the text of the debugger prompt
|PROMPT_COUNT |NLP |TRUE or FALSE |FALSE |Displays the number of items to be input
|PROVENANCE |NLP |TRUE or FALSE |FALSE |Expands trace display to include the line in which a variable was assigned its value
|QMARK_AFTER_PROMPT |NLP |TRUE or FALSE |FALSE |Display '?' after a prompt in an INPUT statement
|RANDOMIZE |NLP |TRUE or FALSE |FALSE |Randomize RND(); without this each run uses the same random sequence
|REQUIRE_INITIALIZED |NLP |TRUE or FALSE |FALSE |Variables must be initialized before use
|TIMING |NLP |TRUE or FALSE |TRUE |After running a program, display time to execute (user time and system time)
|TRACE |NLP |TRUE or FALSE |FALSE |When running a program, display each line prior to execution
|WRAP |NLP |TRUE or FALSE |FALSE |When TRUE, subscripts beyond lower or upper bounds are wrapped
|ZONE_WIDTH |NLP |numeric |16 |Width of print zones for comma separators

Options can be changed when no program is loaded ('N'), when a program is loaded ('L'), or when a program is running ('P').
Options that affect the parsing or analyzing of programs can be changed only when no program is loaded.

When values to constant expressions are cached, setting the PRECISION or BASE options clear the cache of all values.
This is because calculations of constant values can be different after those options change.

Debug shell
-----------

The debug shell lets you pause execution, examine or change the program, and examine or change variables.
The shell is invoked by a breakpoint during a RUN.
Breakpoints are set by the BREAK command.

The debug shell is available only in interactive mode.
It is not available in programs run from the command line.

Commands in the debug shell are:

GO
~~

Continues execution of the program.

STOP
~~~~

Stops the debug shell and the program.

STEP
~~~~

Executes the current line and then re-invokes the debug shell.

BREAK
~~~~~

Display, set, or clear breakpoints.

LIST
~~~~

Lists program lines.

PRETTY
~~~~~~

Pretty-lists program lines.

DELETE
~~~~~~

Deletes program lines.
Actually replaces the lines with blank lines, to avoid confusing the interpreter by deleting the current line.

DIM
~~~

Assigns dimensions to a variable.

GOTO
~~~~

Assigns control to the specified statement.

LET
~~~

Assigns a value or values to a variable or variables.
The assigned value may be a literal or an expression.

PRINT
~~~~~

Prints one or more variables.

PROFILE
~~~~~~~

Prints profile information.
The TIMING option affects the format of the profile information.

Variables
---------

Variables store numeric values.
There are only numeric variables, which handle integer and floating point values automatically.
There are no variable types for text strings, integers, double-precision floats, or objects.

Variable names consist of a single letter and an optional digit and an optional subscript.
Subscripts are enclosed in parentheses.
Values for subscripts are truncated to integers.
The values 2.3 and 2.8 will both be converted to the value 2 when storing or retrieving values.

|==========
|Name |Valid or reason it is not valid
|A |
|B |
|C |
|D1 |
|E0 |
|F |
|F1 |
|F2 |
|G(3) |
|H(17) |
|L(1,0) |
|B[5] |
|AA |Names may have at most one letter
|A10 |Names may have at most one digit after one letter
|9Z |Names must start with a letter
|A_2 |Names may not contain underscore
|K() |Subscripted names must have subscript values
|==========

Variables do not need to be declared.
They are assumed to exist with value zero.

Expressions and operators
-------------------------

BASIC-1965 supports the following arithmetic operations:

|==========
|Operation |Symbol |Precedence
|Addition |+ |3
|Subtraction |- |3
|Multiplication |* |2
|Division |/ |2
|Exponent |^ |1
|==========

Parentheses may be used to force computations is a specific order.
The expression A+B*C performs the multiplication first; the expression (A+B)*C performs the addition first.

Errors in computation (overflow, underflow, and divide by zero) cause execution to stop.

BASIC-1965 supports the following boolean comparisions:

|==========
|Operation |Symbol
|Equal |=
|Not equal |<>
|Greater than |>
|Greater than or equal |>=
|Less than |<
|Less than or equal |<=
|==========

Boolean comparisons are permitted only within IF statements, and only one comparison is allowed per statement.

Numeric values
--------------

Numeric values are either integers or floating point.
Integers are stored internally with Ruby's Fixnum class.
Floating point numbers are stored as Ruby's Float with precision specified by the PRECISION option.

Numeric literals may be integer or real, and may use E-notation with unsigned exponents.
The 'E' must be uppercase; a lowercase 'e' will be rejected.
Exponents may be signed or unsigned.

|==========
|Numeric literal |Valid or reason not valid
|0 |
|1 |
|2 |
|-5 |
|17 |
|123456789 |
|1.03 |
|-2.17 |
|1E4 |
|-2E3 |
|1E-2 |
|2.37E+4 |
|0A |Only digits 0 through 9 and decimal points (and the 'E' for exponent) are permitted
|3.03+E3 |The sign for the exponent must be after the 'E'. (This expression will be parsed as the value 3.03 plus the contents of variable E3.)
1e4 |The 'E' for exponent must be uppercase
|==========

Program statements
------------------

Program statements are stored as part of the program.
Every program statement must have a line number.

A line may contain a comment denoted by a single quote.
Everything to the right of the quote is a comment.

Line numbers
~~~~~~~~~~~~

Line numbers are integers in the range from 1 to 9999.

Empty lines
~~~~~~~~~~~

A line number with no following text is an empty line.
It is retained as part of the program, but performs no action during execution.

Examples:

	10
	120
	6731

DATA
~~~~

Specifies values for READ, ARR READ, and MAT READ statements

Syntax:	DATA value list

Values must be numeric values separated by commas.
Values must be numeric expressions.

Examples:

	390 DATA 3, 150, 175, 180
	400 DATA 2

The DATA statement is processed before the program runs, and processed only once.
Thus, it may appear at the end of the program, and does not have to appear before a READ statement.

But the side effect from processing the statement only once is ... the statement is processed only once (per run).
A DATA statement inside a FOR/NEXT loop is processed only once, not once for each loop execution.

The common behavior for all BASICs is to parse the values as numeric literals.
BASIC-1965 parses the values as numeric expressions, due to its parsing of unary operators as separate from numeric values.
The value '-1' is parsed as a unary minus and the value 1, which must be evaluated as an expression.
This behavior of BASIC-1965 allows for any expression in DATA statements, including the use of variables and functions, but since DATA statements are interpreted before the program is run (and interpreted only once even if contained by a loop) variables will evaluate to zero.

You can use expressions with only numeric literals, operators and functions. Examples are: 3/4 and SIN(0.25).

DEF
~~~

Specifies a user-defined function.

Syntax:	DEF name(parameters) = expression

User-defined functions have names in the form 'FNx' where 'x' is a single letter.

The parameters in the definition must be single letters.
They are not variable names.
The invokation of the function must provide a variable name or a value.
(See examples below.)

The definition for a user-defined function is an expression, similar to the right-hand side of the assignment in a LET statement.
The parameters specified in the definition are substituted into the expression at run-time; other variables specified in the expression are evaluated as usual, using the existing values at the time of execution.

Examples:

	10 DEF FNA(A) = INT(A)
	20 DEF FNB(C) = COS(C)/SIN(C)
	30 DEF FNC(C) = COS(C)/SIN(A)
	100 LET P1 = 3.1415
	105 LET R4 = 20.1
	110 LET A1 = FNA(R4)
	120 LET B1 = FNB(30/P1)
	130 LET A = 30/3.1416
	131 LET A1 = FNC(45/P1)

The DEF statement is processed before the program runs, and processed only once.
Thus, it does not have to appear before it is used in a LET statement.
(Although tradition is that the DEF is specified before the function is used.)

Multiple functions may be defined with the same name, provided they have different signatures.

Examples:

	10 DEF FNA(A) = INT(A)
	20 DEF FNA(C,B) = COS(C)/SIN(B)
	30 DEF FNA(A,B,C) = COS(C)/SIN(A)

DIM
~~~

Specifies the number of dimensions and maximum subscripts for each dimension.
(Without a DIM statement, variables may have a single dimension of at most 10.)

Examples:

	10 DIM A(20)
	20 DIM B(15), C(20,30)

When arrays are zero-based, the DIM A(20) statement allows for values A(0) through A(20).

OPTION BASE 1 changes arrays to one-based, but does not change the upper bound.
With OPTION BASE 1, the statement DIM A(20) allows for values A(1) through A(20).

END
~~~

Marks the end of the program.

An END statement, when executed, will force the execution of the program to stop.

Syntax:	END

Examples:

	999 END

The END statement must be the last statement in the program, and there should be only one of them.

FILES
~~~~~

Defines files to be used in the program.

Syntax:	FILES filenames

Examples:

	20 FILES "test.txt"

File names must be enclosed in double-quotes.
Files must exist at the start of the program, even when the file will be written.
It is not possible for BASIC to create a file.

The requirement that output files exist at the start of execution may strike some as odd, and possibly perverse.
Yet there is a reason behind it: BASIC interpreters of the mid-1960s acted this way.
The notion of a file was a new one, and people thought of files as a special kind of tape file, except one that was written to a disk (or a drum).
When a program used tape files, the operator had to mount the tapes prior to running the program, in order for the program to read and write its files.
The files (or at least devices) existed and were ready to receive instructions.

Disk-based files were considered in the same light, and the operating system had commands for the definition of files and the allocation of space to files.
A program could no more create a file than it could create a magnetic tape.
I have kept this flavor of operation for the FILES command.

FOR
~~~

Performs a sequence of statements for a specific number of times.

Syntax:	FOR control variable = starting value TO ending value
Syntax:	FOR control variable = starting value TO ending value STEP iteration value
Syntax:	FOR control variable = starting value STEP iteration value TO ending value

The statements after the FOR statement (up to the accompanying NEXT statement) are repeated.
The control variable may not have subscripts.
The starting value, ending value, and iteration value may be integers or real.
If the starting value is greater than the ending value (or less than the ending value, when the STEP value is negative) then the statements between the FOR statement and the next NEXT statement with a matching control value are not executed.

A STEP value of zero will cause a loop that does not end.

Examples:

	10 FOR I = 1 TO 10
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 TO 10 STEP 2
	20 PRINT I
	30 NEXT I

	10 FOR I = 1 STEP 0.5 TO 10.5
	20 PRINT I
	30 NEXT I

	10 FOR I = 10 TO 1 STEP -1
	20 PRINT I
	30 NEXT I

It is possible to change the value of the control value within the loop. You can write:

	10 FOR I = 1 TO 10
	20 PRINT A
	30 LET I = 2
	40 NEXT I

This will lock the program into a permanent loop, as the value of I will never reach 10.

The LOCK_FORNEXT option prevents such changes.
When LOCK_FORNEXT is specified, an attempt to change a control variable causes an error.
The variable may be changed after the FOR/NEXT loop terminates.
Note that a GOTO to outside of the FOR/NEXT loop does not terminate the loop or unlock the variable.

Variables may be used to indicate the loop start, end, and step values.
The start, end, and step values are calculated at the beginning of the loop.
They are not re-calculated during the loop execution.
If variables are used, assignments to those variables in the loop will have no affect on the loop.

FORGET
~~~~~~

Removes a variable (or group of variables) from memory.

Syntax: FORGET variable [, variable...]

Examples:
	100 FORGET A
	120 FORGET B,C

The FORGET command is useful with the REQUIRE_INITIALIZED option.
It is a way to force a variable 'out of scope' or to be forgotten.
Forgotten variables are not initialized, and references to them will cause an error.

GO TO
~~~~~

Changes the flow of the program.

Syntax:	GO TO line number
Syntax:	GOTO line number

Examples:

	300 GO TO 100

Notice that the command "350 GO TO 350" is legal but not sensible.
BASIC will detect an infinite loop and stop the program.

GOSUB
~~~~~

Changes the flow of the program by calling a subroutine.

Syntax:	GOSUB line number

Examples:

	300 GOSUB 400

Notice that the command "350 GOSUB 350" is legal but not sensible.
BASIC will detect an infinite loop and stop the program.

IF/THEN
~~~~~~~
Syntax:	IF boolean expression THEN line number

The boolean expression must be in the form "expression operator expression" where operator is limited to the comparion operations listed above.
Boolean operators such as "and" or "or" are not permitted.
The two arguments in the boolean expression may be numeric literals, variables, or arithmetic expressions.
Text values are not allowed.

The "target" after the THEN keyword must be a line number; it cannot be a statement.

Examples:

	100 IF A = 1 THEN 200
	110 IF A > B THEN 250
	120 IF G1 <= G2 THEN 301

INPUT
~~~~~

Loads variables with values from the user or from files.

Inputting from the console
~~~~~~~~~~~~~~~~~~~~~~~~~~

Prompts the user and allows the user to enter a numeric value.
Non-numeric values are invalid and cause execution to stop.

Syntax:	INPUT [prompt,] variable list

Examples:

	60 INPUT U
	65 INPUT V1, V2, V3
	70 INPUT "Enter values: ", A, B

The default prompt is a single question mark (?) character.
This prompt can be changed to any text value by specifying a text value as the first parameter.
(This value must be a text literal.)
When multiple values are specified, they may be entered on one line with commas as separators.
If an insufficient number of values is entered, BASIC will prompt for more data.
These prompts are always the question mark, not the specified prompt.

Inputting from files
~~~~~~~~~~~~~~~~~~~~

Syntax: INPUT #filenum; [prompt,] variable list

Examples:

	60 INPUT #1; U
	65 INPUT #3; V1, V2, V3
	70 INPUT #2; "Enter values: ", A, B

An INPUT statement reads all values from a line of the input file.
Extra values are discarded.
If the line contains an insufficient number of values to fill all variables, BASIC reports an error.

LET
~~~

Assigns a value or group of values to a variable or a group of variables.

Syntax:	LET target variable [, target variable...] = expression

Examples:

	40 LET A = 0
	50 LET B = A + 10
	55 LET C = C + 1
	70 LET D, E = A + B

Expressions may use a combination of operators, functions, and variables.

Variables may be swapped:

	80 LET A, B = B, A

If more values than targets are specified, the extra values are dropped.
If more targets than values are specified, the last value is repeated for the extra targets.

NEXT
~~~~

Denotes the end of a FOR loop.

Syntax:	NEXT control variable

You can GOTO out of FOR/NEXT loops, and BASIC-1965 follows the examples set by Kemeny and Kurtz.

For example:

	10 REM Sample
	20 FOR I = 1 TO 10
	30 PRINT I
	40 IF I = 7 GOTO 60
	50 NEXT I
	60 STOP
	90 END

The above code will print the values 1 through 7 and then stop.

You can GOTO out of a loop and later GOTO back into it.
BASIC-1965 will remember the state of the loop.
If you GOTO into a FOR/NEXT loop (without activating it by the FOR statement), the eventual NEXT statement will cause an error.

The FORGET_FORNEXT option causes the interpreter to forget the value of the control variable when the loop terminates.
This effectively limits the scope of the variable to the FOR/NEXT loop.
Useful when REQUIRE_INITIALIZED is TRUE; a later reference to the control variable will be an error.
BASIC forgets the variable only if it was not defined.
If the variable was defined prior to the FOR, the variable is left defined but modified by the FOR/NEXT loop.

OPTION
~~~~~~

Sets an option for the interpreter.

Syntax: OPTION option expression

Possible options are a subset of the options in the shell.
Refer to the OPTION command for options that can be set in the program.

Expression must evaluate to a value approprate for the option.
It may be a literal, a variable, or a more complex expression.

Examples:

	10 OPTION TRACE TRUE
	40 OPTION PROVENANCE A > 0
	100 OPTION BASE 1

Unlike other interpreters, the OPTION statement is executed in-line.
It is not a setting prior to the execution of the program.

A program may contain multiple OPTION statements.
Each will be executed as a normal statement, in its sequence.

PRINT
~~~~~

Displays a set of variables and literals to the console, with a newline character.

Printing to console
^^^^^^^^^^^^^^^^^^^

Syntax:	PRINT expression list

Items in the list are separated by either commas or semicolons.
A comma forces the next item to the next tab stop (tab stops are every 14 positions).
A semicolon makes the next item adjacent to the previous item (or to the next semicolon zone, if semicolon zones are enabled).

Examples:

	10 PRINT
	20 PRINT A
	30 PRINT A, B
	40 PRINT "Output"
	50 PRINT "Results:", R1
	60 PRINT "Results:"; R2

The list may include terminating separators.
A terminating semicolon will suppress the newline.
A terminating comma will advance to the next tab position and suppress the newline.

	10 PRINT "Processing...";
	... other statements that generate no output
	20 PRINT "done"

results in the text "Processing...done" on the console.

The semicolon separator will force a small space between items.
Between strings, there is no space.
If semicolon zones are enabled (width greater than zero), then BASIC will advance to the next zone.

Printing to files
^^^^^^^^^^^^^^^^^

Syntax:	PRINT #filenum; expression list

Items in the list are separated by either commas or semicolons.
A comma or semicolon writes a SPACE character to the file.

Examples:

	10 PRINT #1
	20 PRINT #2, A
	30 PRINT #3; A, B
	40 PRINT #4; "Output"
	50 PRINT #5, "Results:", R1
	60 PRINT #6, "Results:"; R2

The list may include terminating separators.
A terminating comma or semicolon will write a SPACE and suppress the newline.

	10 PRINT #2; "Processing...";
	... other statements that generate no output
	20 PRINT #2; "done"

results in the text "Processing... done" to the file.

Numbers are printed with automatic formatting.
BASIC-1965 will print a number with the necessary number of decimal places.
It is not possible to force a number of decimal places.

READ
~~~~

Loads variables with values from DATA statements or files.

Reading from DATA statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Syntax:	READ variable list

Examples:

	400 READ N
	410 READ A, B, C

Notice that the number of values in a READ statement do not have to match the number of values in DATA statements.
You may READ in pairs and define ten values per DATA statement.
You may READ ten items from DATA statements that contain one value each.

READing more values than are specified by DATA statements, in total, will cause an error.

BASIC keeps an internal pointer to the next data item.
This pointer can be reset with the RESTORE statement.

Reading from files
^^^^^^^^^^^^^^^^^^

Syntax:	READ #filenum; variable list

Examples:

	400 READ #1; N
	410 READ #2; A, B, C

Files are text files.
Values in the file must be separated by space or separator (comma or semicolon) characters.
The number of values in a READ statement does not have to match the number of values on a line in the input file.
The READ statement will read additional lines and collect values to fill are specified variables.
Values remaining on the text line are saved until the next READ statement.

READing more values than are specified by the file, in total, will cause an error.

BASIC keeps an internal pointer to the next data item.

REM
~~~

Allows for a comment in the program.

Syntax:	REM any text

Examples:

	10 REM
	20 REM Beginning of my first program
	30 REMARK *----*

RESTORE
~~~~~~~

Resets the internal pointer for the READ statement. After a RESTORE statement, a READ statement will read the first data item.

Syntax:	RESTORE

Examples:

	210 RESTORE

RETURN
~~~~~~

Changes the flow of the program by returning from a subroutine.

Syntax:	RETURN

Examples:

	450 RETURN

A RETURN statement makes sense only after the execution of a matching GOSUB statement. A RETURN without a GOSUB will cause an error.

STOP
~~~~

Forces the execution of the program to stop.

Syntax:	STOP

Examples:

	900 STOP

WRITE
~~~~~

Displays a set of variables and literals to the console, with a newline character. The same as the PRINT command, except that WRITE also provides delimiters between values.

Writing to console
^^^^^^^^^^^^^^^^^^

Syntax:	WRITE expression list
Items in the list are separated by either commas or semicolons.

Examples:

	10 WRITE
	20 WRITE A
	30 WRITE A, B
	40 WRITE "Output"
	50 WRITE "Results:", R1
	60 WRITE "Results:"; R2

The list may include terminating separators.
A terminating semicolon will suppress the newline.
A terminating comma will advance to the next tab position and suppress the newline.

	10 WRITE "Processing...";
	... other statements that generate no output
	20 WRITE "done"

results in the text "Processing...", "done" on the console.

Numbers are printed with automatic formatting.
BASIC-1965 will print a number with the necessary number of decimal places.
It is not possible to force a number of decimal places.

Writing to files
^^^^^^^^^^^^^^^^

Syntax:	WRITE #filenum; expression list

Items in the list are separated by either commas or semicolons.
A comma or semicolon writes a SPACE character to the file.

Examples:

	10 WRITE #1
	20 WRITE #2, A
	30 WRITE #3, A, B
	40 WRITE #4; "Output"
	50 WRITE #5, "Results:", R1
	60 WRITE #6; "Results:"; R2

The list may include terminating separators.
A terminating comma or semicolon will write a SPACE and suppress the newline.

	10 WRITE #2; "Processing...";
	... other statements that generate no output
	20 WRITE #2; "done"

results in the text "Processing..."; "done" to the file.

Numbers are printed with automatic formatting.
BASIC-1965 will print a number with the necessary number of decimal places.
It is not possible to force a number of decimal places.

ARR statements
--------------

The ARR statements operate on one-dimensional arrays.
Operations begin with the index specified in OPTION BASE.

ARR FORGET
~~~~~~~~~~

Removes an array variable (or group of array variables) from memory.

Syntax: ARR FORGET variable [, variable...]

Examples:
        100 DIM A(10), B(20), C(33)
	110 REM lots of code here
	400 ARR FORGET A
	420 ARR FORGET B,C

The FORGET command is useful with the REQUIRE_INITIALIZED option.
It is a way to force a variable 'out of scope' or to be forgotten.
Forgotten variables are not initialized, and references to them will cause an error.

The ARR FORGET statement leaves the dimensions for the variable unchanged.

ARR INPUT
~~~~~~~~~

Loads array variables with values from the user or from files.

Inputting from the console
~~~~~~~~~~~~~~~~~~~~~~~~~~

Prompts the user and allows the user to enter a numeric value.
Non-numeric values are invalid and cause execution to stop.

Syntax:	ARR INPUT [prompt,] variable list

Examples:

	60 ARR INPUT U
	65 ARR INPUT V1, V2, V3
	70 ARR INPUT "Enter values: ", A, B

The default prompt is a single question mark (?) character.
This prompt can be changed to any text value by specifying a text value as the first parameter.
(This value must be a text literal.)
When multiple values are specified, they may be entered on one line with commas as separators.
If an insufficient number of values is entered, BASIC will prompt for more data.
These prompts are always the question mark, not the specified prompt.

Inputting from files
~~~~~~~~~~~~~~~~~~~~

Syntax: ARR INPUT #filenum; [prompt,] variable list

Examples:

	60 ARR INPUT #1; U
	65 ARR INPUT #3; V1, V2, V3
	70 ARR INPUT #2; "Enter values: ", A, B

An INPUT statement reads all values from a line of the input file.
Extra values are discarded.
If the line contains an insufficient number of values to fill all variables, BASIC reports an error.

ARR PRINT
~~~~~~~~~

Prints an array of values.

Printing to console
^^^^^^^^^^^^^^^^^^^

Syntax:	ARR PRINT variable list

Examples:

	100 ARR PRINT A
	110 ARR PRINT B;
	120 ARR PRINT A; B;
	130 ARR PRINT C, D

The values must be defined with DIM statements prior to printing.
Values are printed sequentially with as many values as will fit on a line.
The FIELD_SEP option specifies the spacing between values.
The FIELD_SEP SEMI option results in narrow columns, the FIELD_SEP COMMA option (the default) results in wide columns.

Printing to files
^^^^^^^^^^^^^^^^^
 
Syntax:	ARR PRINT #filenum; variable list

Examples:

	100 ARR PRINT #1; A
	110 ARR PRINT #2, B;
	120 ARR PRINT #3; A; B;
	130 ARR PRINT #4; C, D

The values must be defined with DIM statements prior to printing.
Values are printed sequentially with each set of values on one line.

ARR READ
~~~~~~~~

Reads data into an array of values.

Reading from DATA statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Syntax:	ARR READ variable list

Examples:

	100 ARR READ A
	110 ARR READ B, C
	120 ARR READ D(15)

Dimensions may be supplied or omitted in ARR READ statements.
When supplied, they override any previous DIM or ARR READ or MAT READ statement.
When omitted, the variable must have dimensions specified in earlier DIM or ARR READ or MAT READ statements.

The values for dimensions may be numeric literals or expressions.
The expression is evaluated at run-time, like any other expression.

Data is read from DATA statements, as with the READ statement.

Reading from files
^^^^^^^^^^^^^^^^^^

Syntax:	ARR READ #filenum; variable list

Examples:

	400 ARR READ #1; N
	410 ARR READ #2; A, B, C

Files are text files.
Values in the file must be separated by space or separator (comma or semicolon) characters.
The number of values in a READ statement does not have to match the number of values on a line in the input file.
The READ statement will read additional lines and collect values to fill are specified variables.
Values remaining on the text line are saved until the next READ statement.

READing more values than are specified by the file, in total, will cause an error.

BASIC keeps an internal pointer to the next data item.

ARR WRITE
~~~~~~~~~

Writes an array of values with separators.

Writing to console
^^^^^^^^^^^^^^^^^^

Syntax:	ARR WRITE variable list

Examples:

	100 ARR WRITE A
	110 ARR WRITE B;
	120 ARR WRITE A; B;
	130 ARR WRITE C, D

The values must be defined with DIM statements prior to printing.
Values are printed sequentially with as many values as will fit on a line.

Writing to files
^^^^^^^^^^^^^^^^
 
Syntax:	ARR WRITE #filenum; variable list

Examples:

	100 ARR WRITE #1; A
	110 ARR WRITE #2, B;
	120 ARR WRITE #3; A; B;
	130 ARR WRITE #4; C, D

The values must be defined with DIM statements prior to printing.
Values are printed sequentially with each set of values on one line.

ARR LET
~~~~~~~

Assigns a value or group of values to an array variable or group of array variables.

Syntax:	ARR LET target variable [, target variable...] = expression
Syntax:	ARR target variable [, target variable...] = expression

Examples:

	100 ARR LET A = B
	110 ARR LET A = B * C
	120 ARR A = B + D
	130 ARR A = B - E
	140 ARR A = 2 * B
	150 ARR A = 2 * B – E
	160 ARR G,H = A + B

Variables are assumed to represent array values.
If you want to use a scalar variable, enclose it in parentheses:

	130 LET S = 2
	140 ARR A = (S) * B
	150 ARR A = (S) * B - E

The expression is limited to arithmetic operations (addition, subtraction, multiplication, division, and exponentiation).
Certain operations are available for certain combinations of operands:

|==========
|First operand |Operation |Second operand |Restrictions |Actions
|Array |Addition |Array |Arrays must have identical dimensions |Corresponding elements are added
|Array |Subtraction |Array |Arrays must have identical dimensions |Elements from second array are subtracted from corresponding element in first array
|Array |Multiplication |Array |Arrays must have identical dimensions |Corresponding elements are multiplied
|Array |Division |Array |Arrays must have identical dimensions |Elements from the first array are numerators, elements from the second array are denominators
|Array |Power |Array |Arrays must have identical dimensions |Elements from the first array are raised to the corresponding element in the second array
|Scalar |Addition |Array ||Elements from the array are added to the scalar value
|Scalar |Subtraction |Array ||Elements from the array are subtracted from the scalar value
|Scalar |Multiplication |Array ||Elements from the array are multiplied by the scalar value
|Scalar |Division |Array ||Elements from the array are divided into the scalar value
|Scalar |Power |Array ||Elements from the array are the exponent of the scalar value
|Array |Addition |Scalar ||Elements from the array are added to the scalar value
|Array |Subtraction |Scalar ||The scalar value is subtracted from elements in the  array
|Array |Multiplication |Scalar ||Elements from the array are multiplied by the scalar value
|Array |Division |Scalar ||Elements from the array are divided by the scalar value
|Array |Power |Scalar ||Elements from the array are raised to the scalar value
|==========

K&K BASIC makes no mention of the 'ARR' statement or any derived statements ('ARR PRINT', 'ARR READ').
I think that it makes sense to include them.

MAT statements
--------------

The MAT statements operate on matricies, which are either one- or two-dimensional arrays.
Operations begin with the index specified in OPTION BASE.

MAT FORGET
~~~~~~~~~~

Removes a maxtrix variable (or group of matrix variables) from memory.

Syntax: MAT FORGET variable [, variable...]

Examples:
	100 DIM A(3,4), B(10,4), C(100,22)
	110 REM lots of code here
	400 MAT FORGET A
	420 MAT FORGET B,C

The FORGET command is useful with the REQUIRE_INITIALIZED option.
It is a way to force a variable 'out of scope' or to be forgotten.
Forgotten variables are not initialized, and references to them will cause an error.

The MAT FORGET statement leaves the dimensions for the variable unchanged.

MAT INPUT
~~~~~~~~~

Loads matrix variables with values from the user or from files.

Inputting from the console
~~~~~~~~~~~~~~~~~~~~~~~~~~

Prompts the user and allows the user to enter a numeric value.
Non-numeric values are invalid and cause execution to stop.

Syntax:	MAT INPUT [prompt,] variable list

Examples:

	60 MAT INPUT U
	65 MAT INPUT V1, V2, V3
	70 MAT INPUT "Enter values: ", A, B

The default prompt is a single question mark (?) character.
This prompt can be changed to any text value by specifying a text value as the first parameter.
(This value must be a text literal.)
When multiple values are specified, they may be entered on one line with commas as separators.
If an insufficient number of values is entered, BASIC will prompt for more data.
These prompts are always the question mark, not the specified prompt.

Inputting from files
~~~~~~~~~~~~~~~~~~~~

Syntax: MAT INPUT #filenum; [prompt,] variable list

Examples:

	60 MAT INPUT #1; U
	65 MAT INPUT #3; V1, V2, V3
	70 MAT INPUT #2; "Enter values: ", A, B

An INPUT statement reads all values from a line of the input file.
Extra values are discarded.
If the line contains an insufficient number of values to fill all variables, BASIC reports an error.

MAT PRINT
~~~~~~~~~

Prints an array or matrix of values.

Printing to console
^^^^^^^^^^^^^^^^^^^

Syntax:	MAT PRINT variable list

Examples:

	100 MAT PRINT A
	110 MAT PRINT B;
	120 MAT PRINT A; B;
	130 MAT PRINT C, D

The values must be defined with DIM statements prior to printing.

For one-dimensional arrays, the values are printed sequentially with as many values as will fit on a line.

For two-dimensional matrices, values for each row in the matrix are printed on a line and a new line is used for each row.
The FIELD_SEP option specifies the spacing between values.
The FIELD_SEP SEMI option results in narrow columns, the FIELD_SEP COMMA option (the default) results in wide columns.

A newline is printed at the end of each line, so the carriage control characters of ',' and ';' have different meanings.
A comma adds an additional blank line after the matrix is printed.
A semicolon adds no blank line; it does nothing.

Printing to a file
^^^^^^^^^^^^^^^^^^

Syntax:	MAT PRINT #filenum; variable list

Examples:

	100 MAT PRINT #1; A
	110 MAT PRINT #2, B;
	120 MAT PRINT #3; A; B;
	130 MAT PRINT #4; C, D

The values must be defined with DIM statements prior to printing.

For one-dimensional arrays, the values are printed on one line.

For two-dimensional matrices, values for each row in the matrix are printed on a line and a new line is used for each row.

A newline is printed at the end of each line, so the carriage control characters of ',' and ';' have different meanings.
A comma adds an additional blank line after the matrix is printed.
A semicolon adds no blank line; it does nothing.

MAT READ
~~~~~~~~

Reads data into an array or matrix of values.

Reading from DATA statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Syntax:	MAT READ variable list

Examples:

	100 MAT READ A
	110 MAT READ B, C
	120 MAT READ D(15)
	130 MAT READ E(6,11)

Dimensions may be supplied or omitted in MAT READ statements.
When supplied, they override any previous DIM or ARR READ or MAT READ statement.
When omitted, the variable must have dimensions specified in earlier DIM or ARR READ or MAT READ statements.

The values for dimensions may be numeric literals ot expressions.
The expression is evaluated at run-time, like any other expression.

Data is read from DATA statements, as with the READ statement.

Reading from files
^^^^^^^^^^^^^^^^^^

Syntax:	MAT READ #filenum; variable list

Examples:

	400 MAT READ #1; N
	410 MAT READ #2; A, B, C

Files are text files.
Values in the file must be separated by space or separator (comma or semicolon) characters.
The number of values in a READ statement does not have to match the number of values on a line in the input file.
The READ statement will read additional lines and collect values to fill are specified variables.
Values remaining on the text line are saved until the next READ statement.

READing more values than are specified by the file, in total, will cause an error.

BASIC keeps an internal pointer to the next data item.

MAT WRITE
~~~~~~~~~

Writes an array or matrix of values.

Writing to console
^^^^^^^^^^^^^^^^^^

Syntax:	MAT WRITE variable list

Examples:

	100 MAT WRITE A
	110 MAT WRITE B;
	120 MAT WRITE A; B;
	130 MAT WRITE C, D

The values must be defined with DIM statements prior to printing.

For one-dimensional arrays, the values are printed sequentially with as many values as will fit on a line.

For two-dimensional matrices, values for each row in the matrix are printed on a line and a new line is used for each row.

Writing to a file
^^^^^^^^^^^^^^^^^

Syntax:	MAT WRITE #filenum; variable list

Examples:

	100 MAT WRITE #1; A
	110 MAT WRITE #2, B;
	120 MAT WRITE #3; A; B;
	130 MAT WRITE #4; C, D

The values must be defined with DIM statements prior to printing.

For one-dimensional arrays, the values are printed on one line.

For two-dimensional matrices, values for each row in the matrix are printed on a line and a new line is used for each row.

MAT LET
~~~~~~~

Assigns a value or group of values to a matrix variable or group of matrix variables.

Syntax:	MAT LET target variable [, target variable...] = expression
Syntax:	MAT target variable [, target variable...] = expression

Examples:

	100 MAT LET A = B
	110 MAT LET A = B * C
	120 MAT A = B + D
	130 MAT A = B - E
	140 MAT A = 2 * B
	150 MAT A = 2 * B – E
	160 MAT G,H = A + B

Variables are assumed to represent matrix values.
They may refer to variables dimensioned with one or two variables.

If you want to use a scalar variable, enclose it in parentheses:

	130 LET S = 2
	140 MAT A = (S) * B
	150 MAT A = (S) * B - E

The expression is limited to arithmetic operations (addition, subtraction, multiplication, division, and exponentiation).
Certain operations are available for certain combinations of operands:

|==========
|First operand |Operation |Second operand |Restrictions |Actions
|Matrix |Addition |Matrix |Matrices must have identical dimensions |Corresponding elements are added
|Matrix |Subtraction |Matrix |Matrices must have identical dimensions |Elements from second matrix are subtracted from corresponding element in first matrix
|Matrix |Multiplication |Matrix |Number of columns in second matrix must equal number of rows in first matrix |Computes dot product, which contains the number of columns of the first matrix and the number of rows in the second matrix
|Matrix |Division |Matrix |Not allowed |
|Matrix |Power |Matrix |Not allowed |
|Scalar |Addition |Matrix ||Elements from the matrix are added to the scalar value
|Scalar |Subtraction |Matrix ||Elements from the matrix are subtracted from the scalar value
|Scalar |Multiplication |Matrix ||Elements from the matrix are multiplied by the scalar value
|Scalar |Division |Matrix ||Elements from the matrix are divided into the scalar value
|Scalar |Power |Matrix ||Elements from the matrix are the exponent of the scalar value
|Matrix |Addition |Scalar ||Elements from the matrix are added to the scalar value
|Matrix |Subtraction |Scalar ||The scalar value is subtracted from elements in the matrix
|Matrix |Multiplication |Scalar ||Elements from the matrix are multiplied by the scalar value
|Matrix |Division |Scalar ||Elements from the matrix are divided by the scalar value
|Matrix |Power |Scalar | |Elements from the matrix are raised to the scalar value
|==========

K&K BASIC restricts the assignment of a variable used in a matrix multiplication operation.
BASIC-1965 does not impose this restriction.
You may write:

	110 MAT A = A * C

Functions
---------

Functions may be used in numeric expressions.

|==========
|Function |Result
|ABS(x) |numeric |Computes the absolute value of x.
|ARCCOS(x) |numeric |Computes the arccosine of x, providing the answer in radians.
|ARCSIN(x) |numeric |Computes the arcsine of x, providing the answer in radians.
|ARCTAN(x) |numeric |Computes the arctangent of x, providing the answer in radians.
|ARCTAN(y,x) |numeric |Computes the arctangent of y and x, providing the answer in radians.
|ATN(x) |numeric |Synonym for ARCTAN(x).
|ATN(y,x) |numeric |Synonym for ARCTAN(y,x).
|AVG(a) |numeric |Computes average of elements in array.
|CON2(n) |numeric matrix |Creates a matrix containing all ones, with n columns.
|CON1(n) |numeric array |Creates an array containing all ones, with n values.
|CON(n) |numeric matrix |Synonym for CON2(n).
|CON2(r,c) |numeric matrix |Creates a matrix containing all ones, with r rows and c columns.
|CON(r,c) |numeric matrix |Synonym for CON2(r,c).
|CON() |numeric matrix |Creates a matrix containing all ones, with dimensions based on the assignment target.
|CON |numeric matrix |Special form of CON().
|COS(x) |numeric |Computes the cosine of x, where x is in radians.
|COT(x) |numeric |Computes the cotangent of x, where x is in radians.
|CSC(x) |numeric |Computes the cosecant of x, where x is in radians.
|DET(m)	|numeric |Computes the determinant of the matrix. The matrix must be square.
|EXP(x) |numeric |Computes e to the x power.
|FIX(x) |numeric |Returns the integer part of a number. Truncates towards negative infinity.
|FRAC(x) |numeric |Return the fraction part of a numeric value. Retains the sign of the original value.
|IDN(x) |numeric matrix |Creates an identity matrix (all zeros except for ones on the diagonal).
|IDN(x,x) |numeric matrix |Same as IDN(x). The two values must be identical, as identity matrices are always square.
|IDN or IDN() |numeric matrix |Creates an identity matrix with dimensions based on the assignment target.
|INT(x) |numeric |Return the integer part of a numeric value. Truncates towards zero.
|INV(m) |numeric matrix |Inverts matrix m.
|LOG(x) |numeric |Computes the natural log of x. A value of zero or a negative value will cause an error.
|LOG10(x) |numeric |Computes the base-10 log of x. A value of zero or a negative value will cause an error.
|LOG2(x) |numeric |Computes the base-2 log of x. A value of zero or a negative value will cause an error.
|MOD(a,b) |numeric |Computes 'a modulus b'.
|NCOL(m) |numeric |Number of columns in matrix m.
|NELEM(a) |numeric |Number of elements in array a.
|NROW(m) |numeric |Number of rows in matrix m.
|PROD(a) |numeric |Computes product of elements in array.
|RND(x) |numeric |Return a random number from zero to x. The value is a floating-point value; RND(1) can return any value from zero to 1. A value of zero or less than zero is considered to be 1.
|RND() |numeric |Equivalent to RND(1).
|RND |numeric |Special form of RND, equivalent to RND(1).
|ROUND(x,p) |numeric |Rounds the value x to p places.
|SEC(x) |numeric |Computes the secant of x, where x is in radians.
|SGN(x) |numeric |Returns 1, 0, or -1, for positive, zero, or negative values of x.
|SIN(x) |numeric |Computes the sine of x, where x is in radians.
|SQR(x) |numeric |Computes the square root of x. A negative value will cause an error.
|SUM(a) |numeric |Computes sum of elements in array.
|TAN(x) |numeric |Computes the tangent of x, where x is in radians.
|TRN(m) |numeric matrix |Transposes values in a matrix, exchanging rows and columns.
|ZER2(n) |numeric matrix|Creates a matrix containing all zeros, with n columns
|ZER1(n) |numeric array |Creates an array containing all zeros, with n values
|ZER(n) |numeric matrix|Synonym for ZER2(n)
|ZER2(r,c) |numeric matrix |Creates a matrix containing all zeros, with r rows and c columns.
|ZER(r,c) |numeric matrix |Synonym for ZER2(r,c).
|ZER() |numeric matrix |Creates a matrix containing all zeros, with dimensions based on the assignment target.
|ZER |numeric matrix |Special form of ZER().
|===========

Array and matrix function special forms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The functions CON(), CON1(), CON2(), ZER(), ZER1(), ZER2(), and IDN() have normal forms and special forms.
You can use the normal form in simple assignments without specifying dimensions of targets:

	200 REM NO DIM STATEMENT FOR A OR B
	240 MAT A = CON(3,4)
	250 MAT B = IDN(4,4)
	260 ARR C = ZER1(7)

The special form allows for parameters to be omitted.

	200 REM DIM STATEMENTS FOR A AND B ARE NECESSARY
	230 DIM A(3,4), B(4,4), C(7)
	240 MAT A = CON
	250 MAT B = IDN
	260 ARR C = ZER1

In this special form, the target variable must already exist and have dimensions specified.

ABS(n)
~~~~~~

Computes the absolute value of n.

ARCCOS(n)
~~~~~~~~~

Computes the arccosine of n, providing the answer in radians.

ARCSIN(n)
~~~~~~~~~

Computes the arcsine of n, providing the answer in radians.


ARCTAN(n)
~~~~~~~~~

Computes the arctangent of n, providing the answer in radians.
Provides inexact answers for small n; use ARCTAN(y, x) for small angles.

ARCTAN(y,x)
~~~~~~~~~~~

Computes the arctangent of y and x, providing the answer in radians.


ATN(n)
~~~~~~

Synonym for ARCTAN(n).


ATN(y,x)
~~~~~~~~

Synonym for ARCTAN(y,x).


AVG(a)
~~~~~~

Computes average of elements in array a.

CON2(n)
~~~~~~~

Creates a matrix containing all ones, with n rows and n columns.

CON1(n)
~~~~~~~

Creates an array containing all ones, with n values.

CON(n)
~~~~~~

Synonym for CON2(n).

CON2(r,c)
~~~~~~~~~

Creates a matrix containing all ones, with r rows and c columns.

CON(r,c)
~~~~~~~~

Synonym for CON2(r,c).

CON()
~~~~~

Creates a matrix containing all ones, with dimensions based on the assignment target.

CON
~~~

Special form of CON().

COS(r)
~~~~~~

Computes the cosine of r, where r is in radians.

COT(r)
~~~~~~

Computes the cotangent of r, where r is in radians.

CSC(r)
~~~~~~

Computes the cosecant of r, where r is in radians.

DET(m)
~~~~~~

Computes the determinant of the matrix. The matrix must be square.

EXP(x)
~~~~~~

Computes e to the x power.

FIX(n)
~~~~~~

Returns the integer part of a number. Truncates towards negative infinity.

FRAC(n)
~~~~~~~

Return the fraction part of a numeric value. Retains the sign of the original value.

IDN(n)
~~~~~~

Creates an identity matrix (all zeros except for ones on the diagonal) with n rows and n columns.

IDN(n,n)
~~~~~~~~

Same as IDN(n). The two values must be identical, as identity matrices are always square.

IDN()
~~~~~

Creates an identity matrix with dimensions based on the assignment target.

IDN
~~~

Special form of IDN().

INT(x)
~~~~~~

Return the integer part of a numeric value. Truncates towards zero.

INV(m)
~~~~~~

Inverts matrix m.

LOG(x)
~~~~~~

Computes the natural log of x. A value of zero or a negative value for x will cause an error.

LOG10(x)
~~~~~~~~

Computes the base-10 log of x. A value of zero or a negative value for x will cause an error.

LOG2(x)
~~~~~~~

Computes the base-2 log of x. A value of zero or a negative value for x will cause an error.

MOD(a,b)
~~~~~~~~

Computes 'a modulus b'.

NCOL(m)
~~~~~~~

Number of columns in matrix m.

NELEM(a)
~~~~~~~~

Number of elements in array a.

NROW(m)
~~~~~~~

Number of rows in matrix m.

PROD(a)
~~~~~~~

Computes product of elements in array.

RND(x)
~~~~~~

Return a random number from zero to x.
The value is a floating-point value; RND(1) can return any value from zero to 1.
A value of zero or less than zero is considered to be 1.

RND()
~~~~~

Equivalent to RND(1).

RND
~~~

Special form of RND, equivalent to RND(1).

ROUND(x,p)
~~~~~~~~~~

Rounds the value x to p places.

SEC(r)
~~~~~~

Computes the secant of r, where r is in radians.

SGN(n)
~~~~~~

Returns 1, 0, or -1, for positive, zero, or negative values of n.

SIN(r)
~~~~~~

Computes the sine of r, where r is in radians.

SQR(x)
~~~~~~

Computes the square root of x.
A negative value will cause an error.

SUM(a)
~~~~~~

Computes sum of elements in array.

TAN(r)
~~~~~~

Computes the tangent of r, where r is in radians.

TRN(m)
~~~~~~

Transposes values in a matrix, exchanging rows and columns.

ZER1(n)
~~~~~~~

Creates an array containing all zeros, with n values.

ZER2(n)
~~~~~~~

Creates a matrix containing all zeros, with n columns and n rows.

ZER(n)
~~~~~~

Synonym for ZER2(n).

ZER2(r,c)
~~~~~~~~~

Creates a matrix containing all zeros, with r rows and c columns.

ZER(r,c)
~~~~~~~~

Synonym for ZER2(r,c).

ZER()
~~~~~

Creates a matrix containing all zeros, with dimensions based on the assignment target.

ZER
~~~

Special form of ZER().


Editing programs
----------------

Programs may be edited externally and loaded with the LOAD command, and they may be entered and edited within BASIC-1965.

An entered line is parsed and either executed or stored as part of the program.
Lines that begin with numbers are considered part of the program; lines without numbers are executed immediately.

To replace a line, enter a line with the number of the old line.
You must enter the entire line; there are no 'line editing' capabilities.

Infinite loops
--------------

The interpreter detects infinite loops in some situations.
When it detects an infinite loop, it stops the program.
The detection algorithm is weak, and it will miss most infinite loops.
The detection algorithm is:

	keep a list of the line numbers for executed statements
	if the statement about to be executed is in the list, report an infinite loop
	when a variable is set to a new value (different than current value), clear the list
	INPUT, LINE INPUT, and READ statements (console or files) will also clear the list
	a statement which invokes the RND() function also clears the list

This algorithm will detect simple infinite loops such as

	10 PRINT "HELLO"
	20 GOTO 10

and

	10 LET A = 1
	20 IF A < 5 THEN 10

and

	10 GOTO 10

and also

	10 FOR I = 1 TO 10 STEP 0

The detection algorithm is not perfect, and it is easy to write a program with an infinite loop that evades detection:

    	10 LET A = 1
	20 PRINT A
	30 LET A = A + 1
	40 GOTO 20
	99 END

The algorithm may detect false positives - infinite loops when none exist.
The DETECT_INFINITE_LOOP option, when set to FALSE, disables checks for infinite loops.


Commentary
----------

File format
~~~~~~~~~~~

Source files
^^^^^^^^^^^^

Source files are stored in ASCII.

Source files contain three groups of line: options, source, and breakpoints.
Option lines begin with the keyword '.OPTION'.
Source lines begin with a line number.
Breakpoint lines begin with the keyword '.BREAK'

Other lines are considered errors.

There is no continuation of lines.

Data files
^^^^^^^^^^

Data files are stored in ASCII.

Data files consist of lines of text, and each line of text consists of fields.
Fields are separated by delimiters, which may be ',' or ';'.
The WRITE statement inserts delimiters.
The PRINT statement does not insert delimiters.
To write a file in BASIC and then read that file in BASIC, use WRITE statements or PRINT statements with delimiters between fields.

To write the file:

100 WRITE #1, A, B, C
110 PRINT #1, A; ","; B; ","; C

To read the file

200 READ #2, A, B, C
210 INPUT #2, A, B, C

END statement
~~~~~~~~~~~~~

The END statement is a puzzle.
Why do we need an END statement when the interpreter holds the entire list of statements?
Does it not know the end of its own data structure?

END will cause execution to STOP, which is a proper action.
But why not simply use a STOP statement?
Or why not simply stop execution when the interpreter encounters the end of the list of statements?

END seems to be a vestige of FORTRAN programming.
FORTRAN needed an END to signal the compiler that the module was complete, and a separate STOP statement to generate code to return control to the operating system.

Further readings indicate that the END statement preceded the STOP statement; that is the very early implementations of BASIC had END but not STOP.
It might be that STOP was added later, and END was kept for compatibility.
